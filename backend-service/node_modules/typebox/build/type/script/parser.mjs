// deno-fmt-ignore-file
// deno-lint-ignore-file
import * as S from './mapping.mjs';
import * as Token from './token/index.mjs';
const If = (result, left, right = () => []) => result.length === 2 ? left(result) : right();
export const GenericParameterExtendsEquals = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('extends', input), ([_1, input]) => If(Type(input), ([_2, input]) => If(Token.Const('=', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.GenericParameterExtendsEqualsMapping(_0), input]);
export const GenericParameterExtends = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('extends', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericParameterExtendsMapping(_0), input]);
export const GenericParameterEquals = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('=', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericParameterEqualsMapping(_0), input]);
export const GenericParameterIdentifier = (input) => If(Token.Ident(input), ([_0, input]) => [S.GenericParameterIdentifierMapping(_0), input]);
export const GenericParameter = (input) => If(If(GenericParameterExtendsEquals(input), ([_0, input]) => [_0, input], () => If(GenericParameterExtends(input), ([_0, input]) => [_0, input], () => If(GenericParameterEquals(input), ([_0, input]) => [_0, input], () => If(GenericParameterIdentifier(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.GenericParameterMapping(_0), input]);
export const GenericParameterList_0 = (input, result = []) => If(If(GenericParameter(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => GenericParameterList_0(input, [...result, _0]), () => [result, input]);
export const GenericParameterList = (input) => If(If(GenericParameterList_0(input), ([_0, input]) => If(If(If(GenericParameter(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericParameterListMapping(_0), input]);
export const GenericParameters = (input) => If(If(Token.Const('<', input), ([_0, input]) => If(GenericParameterList(input), ([_1, input]) => If(Token.Const('>', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericParametersMapping(_0), input]);
export const GenericCallArgumentList_0 = (input, result = []) => If(If(Type(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => GenericCallArgumentList_0(input, [...result, _0]), () => [result, input]);
export const GenericCallArgumentList = (input) => If(If(GenericCallArgumentList_0(input), ([_0, input]) => If(If(If(Type(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericCallArgumentListMapping(_0), input]);
export const GenericCallArguments = (input) => If(If(Token.Const('<', input), ([_0, input]) => If(GenericCallArgumentList(input), ([_1, input]) => If(Token.Const('>', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericCallArgumentsMapping(_0), input]);
export const GenericCall = (input) => If(If(Token.Ident(input), ([_0, input]) => If(GenericCallArguments(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericCallMapping(_0), input]);
export const KeywordString = (input) => If(Token.Const('string', input), ([_0, input]) => [S.KeywordStringMapping(_0), input]);
export const KeywordNumber = (input) => If(Token.Const('number', input), ([_0, input]) => [S.KeywordNumberMapping(_0), input]);
export const KeywordBoolean = (input) => If(Token.Const('boolean', input), ([_0, input]) => [S.KeywordBooleanMapping(_0), input]);
export const KeywordUndefined = (input) => If(Token.Const('undefined', input), ([_0, input]) => [S.KeywordUndefinedMapping(_0), input]);
export const KeywordNull = (input) => If(Token.Const('null', input), ([_0, input]) => [S.KeywordNullMapping(_0), input]);
export const KeywordInteger = (input) => If(Token.Const('integer', input), ([_0, input]) => [S.KeywordIntegerMapping(_0), input]);
export const KeywordBigInt = (input) => If(Token.Const('bigint', input), ([_0, input]) => [S.KeywordBigIntMapping(_0), input]);
export const KeywordUnknown = (input) => If(Token.Const('unknown', input), ([_0, input]) => [S.KeywordUnknownMapping(_0), input]);
export const KeywordAny = (input) => If(Token.Const('any', input), ([_0, input]) => [S.KeywordAnyMapping(_0), input]);
export const KeywordObject = (input) => If(Token.Const('object', input), ([_0, input]) => [S.KeywordObjectMapping(_0), input]);
export const KeywordNever = (input) => If(Token.Const('never', input), ([_0, input]) => [S.KeywordNeverMapping(_0), input]);
export const KeywordSymbol = (input) => If(Token.Const('symbol', input), ([_0, input]) => [S.KeywordSymbolMapping(_0), input]);
export const KeywordVoid = (input) => If(Token.Const('void', input), ([_0, input]) => [S.KeywordVoidMapping(_0), input]);
export const KeywordThis = (input) => If(Token.Const('this', input), ([_0, input]) => [S.KeywordThisMapping(_0), input]);
export const Keyword = (input) => If(If(KeywordString(input), ([_0, input]) => [_0, input], () => If(KeywordNumber(input), ([_0, input]) => [_0, input], () => If(KeywordBoolean(input), ([_0, input]) => [_0, input], () => If(KeywordUndefined(input), ([_0, input]) => [_0, input], () => If(KeywordNull(input), ([_0, input]) => [_0, input], () => If(KeywordInteger(input), ([_0, input]) => [_0, input], () => If(KeywordBigInt(input), ([_0, input]) => [_0, input], () => If(KeywordUnknown(input), ([_0, input]) => [_0, input], () => If(KeywordAny(input), ([_0, input]) => [_0, input], () => If(KeywordObject(input), ([_0, input]) => [_0, input], () => If(KeywordNever(input), ([_0, input]) => [_0, input], () => If(KeywordSymbol(input), ([_0, input]) => [_0, input], () => If(KeywordVoid(input), ([_0, input]) => [_0, input], () => If(KeywordThis(input), ([_0, input]) => [_0, input], () => [])))))))))))))), ([_0, input]) => [S.KeywordMapping(_0), input]);
export const TemplateInterpolate = (input) => If(If(Token.Const('${', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TemplateInterpolateMapping(_0), input]);
export const TemplateSpan = (input) => If(Token.Until(['${', '`'], input), ([_0, input]) => [S.TemplateSpanMapping(_0), input]);
export const TemplateBody = (input) => If(If(If(TemplateSpan(input), ([_0, input]) => If(TemplateInterpolate(input), ([_1, input]) => If(TemplateBody(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(TemplateSpan(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(TemplateSpan(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.TemplateBodyMapping(_0), input]);
export const TemplateLiteralTypes = (input) => If(If(Token.Const('`', input), ([_0, input]) => If(TemplateBody(input), ([_1, input]) => If(Token.Const('`', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TemplateLiteralTypesMapping(_0), input]);
export const TemplateLiteral = (input) => If(TemplateLiteralTypes(input), ([_0, input]) => [S.TemplateLiteralMapping(_0), input]);
export const LiteralBigInt = (input) => If(Token.BigInt(input), ([_0, input]) => [S.LiteralBigIntMapping(_0), input]);
export const LiteralBoolean = (input) => If(If(Token.Const('true', input), ([_0, input]) => [_0, input], () => If(Token.Const('false', input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.LiteralBooleanMapping(_0), input]);
export const LiteralNumber = (input) => If(Token.Number(input), ([_0, input]) => [S.LiteralNumberMapping(_0), input]);
export const LiteralString = (input) => If(Token.String(['\'', '\"'], input), ([_0, input]) => [S.LiteralStringMapping(_0), input]);
export const Literal = (input) => If(If(LiteralBigInt(input), ([_0, input]) => [_0, input], () => If(LiteralBoolean(input), ([_0, input]) => [_0, input], () => If(LiteralNumber(input), ([_0, input]) => [_0, input], () => If(LiteralString(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.LiteralMapping(_0), input]);
export const KeyOf = (input) => If(If(If(Token.Const('keyof', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.KeyOfMapping(_0), input]);
export const IndexArray_0 = (input, result = []) => If(If(If(Token.Const('[', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(Token.Const('[', input), ([_0, input]) => If(Token.Const(']', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => IndexArray_0(input, [...result, _0]), () => [result, input]);
export const IndexArray = (input) => If(IndexArray_0(input), ([_0, input]) => [S.IndexArrayMapping(_0), input]);
export const Extends = (input) => If(If(If(Token.Const('extends', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const('?', input), ([_2, input]) => If(Type(input), ([_3, input]) => If(Token.Const(':', input), ([_4, input]) => If(Type(input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExtendsMapping(_0), input]);
export const Base = (input) => If(If(If(Token.Const('(', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const(')', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(Keyword(input), ([_0, input]) => [_0, input], () => If(_Object_(input), ([_0, input]) => [_0, input], () => If(Tuple(input), ([_0, input]) => [_0, input], () => If(TemplateLiteral(input), ([_0, input]) => [_0, input], () => If(Literal(input), ([_0, input]) => [_0, input], () => If(Constructor(input), ([_0, input]) => [_0, input], () => If(Function(input), ([_0, input]) => [_0, input], () => If(Mapped(input), ([_0, input]) => [_0, input], () => If(Options(input), ([_0, input]) => [_0, input], () => If(GenericCall(input), ([_0, input]) => [_0, input], () => If(Reference(input), ([_0, input]) => [_0, input], () => [])))))))))))), ([_0, input]) => [S.BaseMapping(_0), input]);
export const Factor = (input) => If(If(KeyOf(input), ([_0, input]) => If(Base(input), ([_1, input]) => If(IndexArray(input), ([_2, input]) => If(Extends(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.FactorMapping(_0), input]);
export const ExprTermTail = (input) => If(If(If(Token.Const('&', input), ([_0, input]) => If(Factor(input), ([_1, input]) => If(ExprTermTail(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExprTermTailMapping(_0), input]);
export const ExprTerm = (input) => If(If(Factor(input), ([_0, input]) => If(ExprTermTail(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprTermMapping(_0), input]);
export const ExprTail = (input) => If(If(If(Token.Const('|', input), ([_0, input]) => If(ExprTerm(input), ([_1, input]) => If(ExprTail(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExprTailMapping(_0), input]);
export const Expr = (input) => If(If(ExprTerm(input), ([_0, input]) => If(ExprTail(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprMapping(_0), input]);
export const ExprPipe = (input) => If(If(Token.Const('|', input), ([_0, input]) => If(Expr(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprPipeMapping(_0), input]);
export const GenericType = (input) => If(If(GenericParameters(input), ([_0, input]) => If(Token.Const('=', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericTypeMapping(_0), input]);
export const InferType = (input) => If(If(If(Token.Const('infer', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(Token.Const('extends', input), ([_2, input]) => If(Expr(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [_0, input], () => If(If(Token.Const('infer', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.InferTypeMapping(_0), input]);
export const Type = (input) => If(If(InferType(input), ([_0, input]) => [_0, input], () => If(ExprPipe(input), ([_0, input]) => [_0, input], () => If(Expr(input), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.TypeMapping(_0), input]);
export const PropertyKeyNumber = (input) => If(Token.Number(input), ([_0, input]) => [S.PropertyKeyNumberMapping(_0), input]);
export const PropertyKeyIdent = (input) => If(Token.Ident(input), ([_0, input]) => [S.PropertyKeyIdentMapping(_0), input]);
export const PropertyKeyQuoted = (input) => If(Token.String(['\'', '\"'], input), ([_0, input]) => [S.PropertyKeyQuotedMapping(_0), input]);
export const PropertyKeyIndex = (input) => If(If(Token.Const('[', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(If(KeywordInteger(input), ([_0, input]) => [_0, input], () => If(KeywordNumber(input), ([_0, input]) => [_0, input], () => If(KeywordString(input), ([_0, input]) => [_0, input], () => If(KeywordSymbol(input), ([_0, input]) => [_0, input], () => [])))), ([_3, input]) => If(Token.Const(']', input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.PropertyKeyIndexMapping(_0), input]);
export const PropertyKey = (input) => If(If(PropertyKeyNumber(input), ([_0, input]) => [_0, input], () => If(PropertyKeyIdent(input), ([_0, input]) => [_0, input], () => If(PropertyKeyQuoted(input), ([_0, input]) => [_0, input], () => If(PropertyKeyIndex(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.PropertyKeyMapping(_0), input]);
export const Readonly = (input) => If(If(If(Token.Const('readonly', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ReadonlyMapping(_0), input]);
export const Optional = (input) => If(If(If(Token.Const('?', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.OptionalMapping(_0), input]);
export const Property = (input) => If(If(Readonly(input), ([_0, input]) => If(PropertyKey(input), ([_1, input]) => If(Optional(input), ([_2, input]) => If(Token.Const(':', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.PropertyMapping(_0), input]);
export const PropertyDelimiter = (input) => If(If(If(Token.Const(',', input), ([_0, input]) => If(Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const(';', input), ([_0, input]) => If(Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const(',', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(Token.Const(';', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(Token.Const('\n', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))))), ([_0, input]) => [S.PropertyDelimiterMapping(_0), input]);
export const PropertyList_0 = (input, result = []) => If(If(Property(input), ([_0, input]) => If(PropertyDelimiter(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => PropertyList_0(input, [...result, _0]), () => [result, input]);
export const PropertyList = (input) => If(If(PropertyList_0(input), ([_0, input]) => If(If(If(Property(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.PropertyListMapping(_0), input]);
export const Properties = (input) => If(If(Token.Const('{', input), ([_0, input]) => If(PropertyList(input), ([_1, input]) => If(Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.PropertiesMapping(_0), input]);
export const _Object_ = (input) => If(Properties(input), ([_0, input]) => [S._Object_Mapping(_0), input]);
export const ElementNamed = (input) => If(If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Token.Const('readonly', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [_0, input], () => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Token.Const('readonly', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [_0, input], () => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [_0, input], () => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.ElementNamedMapping(_0), input]);
export const ElementReadonlyOptional = (input) => If(If(Token.Const('readonly', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const('?', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.ElementReadonlyOptionalMapping(_0), input]);
export const ElementReadonly = (input) => If(If(Token.Const('readonly', input), ([_0, input]) => If(Type(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementReadonlyMapping(_0), input]);
export const ElementOptional = (input) => If(If(Type(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementOptionalMapping(_0), input]);
export const ElementBase = (input) => If(If(ElementNamed(input), ([_0, input]) => [_0, input], () => If(ElementReadonlyOptional(input), ([_0, input]) => [_0, input], () => If(ElementReadonly(input), ([_0, input]) => [_0, input], () => If(ElementOptional(input), ([_0, input]) => [_0, input], () => If(Type(input), ([_0, input]) => [_0, input], () => []))))), ([_0, input]) => [S.ElementBaseMapping(_0), input]);
export const Element = (input) => If(If(If(Token.Const('...', input), ([_0, input]) => If(ElementBase(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(ElementBase(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ElementMapping(_0), input]);
export const ElementList_0 = (input, result = []) => If(If(Element(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => ElementList_0(input, [...result, _0]), () => [result, input]);
export const ElementList = (input) => If(If(ElementList_0(input), ([_0, input]) => If(If(If(Element(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementListMapping(_0), input]);
export const Tuple = (input) => If(If(Token.Const('[', input), ([_0, input]) => If(ElementList(input), ([_1, input]) => If(Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TupleMapping(_0), input]);
export const ParameterReadonlyOptional = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Token.Const('readonly', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.ParameterReadonlyOptionalMapping(_0), input]);
export const ParameterReadonly = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Token.Const('readonly', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ParameterReadonlyMapping(_0), input]);
export const ParameterOptional = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ParameterOptionalMapping(_0), input]);
export const ParameterType = (input) => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.ParameterTypeMapping(_0), input]);
export const ParameterBase = (input) => If(If(ParameterReadonlyOptional(input), ([_0, input]) => [_0, input], () => If(ParameterReadonly(input), ([_0, input]) => [_0, input], () => If(ParameterOptional(input), ([_0, input]) => [_0, input], () => If(ParameterType(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.ParameterBaseMapping(_0), input]);
export const Parameter = (input) => If(If(If(Token.Const('...', input), ([_0, input]) => If(ParameterBase(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(ParameterBase(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ParameterMapping(_0), input]);
export const ParameterList_0 = (input, result = []) => If(If(Parameter(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => ParameterList_0(input, [...result, _0]), () => [result, input]);
export const ParameterList = (input) => If(If(ParameterList_0(input), ([_0, input]) => If(If(If(Parameter(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ParameterListMapping(_0), input]);
export const Function = (input) => If(If(Token.Const('(', input), ([_0, input]) => If(ParameterList(input), ([_1, input]) => If(Token.Const(')', input), ([_2, input]) => If(Token.Const('=>', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.FunctionMapping(_0), input]);
export const Constructor = (input) => If(If(Token.Const('new', input), ([_0, input]) => If(Token.Const('(', input), ([_1, input]) => If(ParameterList(input), ([_2, input]) => If(Token.Const(')', input), ([_3, input]) => If(Token.Const('=>', input), ([_4, input]) => If(Type(input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.ConstructorMapping(_0), input]);
export const MappedReadonly = (input) => If(If(If(Token.Const('+', input), ([_0, input]) => If(Token.Const('readonly', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('-', input), ([_0, input]) => If(Token.Const('readonly', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('readonly', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.MappedReadonlyMapping(_0), input]);
export const MappedOptional = (input) => If(If(If(Token.Const('+', input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('-', input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('?', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.MappedOptionalMapping(_0), input]);
export const MappedAs = (input) => If(If(If(Token.Const('as', input), ([_0, input]) => If(Type(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.MappedAsMapping(_0), input]);
export const Mapped = (input) => If(If(Token.Const('{', input), ([_0, input]) => If(MappedReadonly(input), ([_1, input]) => If(Token.Const('[', input), ([_2, input]) => If(Token.Ident(input), ([_3, input]) => If(Token.Const('in', input), ([_4, input]) => If(Type(input), ([_5, input]) => If(MappedAs(input), ([_6, input]) => If(Token.Const(']', input), ([_7, input]) => If(MappedOptional(input), ([_8, input]) => If(Token.Const(':', input), ([_9, input]) => If(Type(input), ([_10, input]) => If(Token.Const('}', input), ([_11, input]) => [[_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11], input])))))))))))), ([_0, input]) => [S.MappedMapping(_0), input]);
export const Reference = (input) => If(Token.Ident(input), ([_0, input]) => [S.ReferenceMapping(_0), input]);
export const Options = (input) => If(If(Token.Const('Options', input), ([_0, input]) => If(Token.Const('<', input), ([_1, input]) => If(Type(input), ([_2, input]) => If(Token.Const(',', input), ([_3, input]) => If(JsonObject(input), ([_4, input]) => If(Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.OptionsMapping(_0), input]);
export const JsonNumber = (input) => If(Token.Number(input), ([_0, input]) => [S.JsonNumberMapping(_0), input]);
export const JsonBoolean = (input) => If(If(Token.Const('true', input), ([_0, input]) => [_0, input], () => If(Token.Const('false', input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.JsonBooleanMapping(_0), input]);
export const JsonString = (input) => If(Token.String(['\"', '\''], input), ([_0, input]) => [S.JsonStringMapping(_0), input]);
export const JsonNull = (input) => If(Token.Const('null', input), ([_0, input]) => [S.JsonNullMapping(_0), input]);
export const JsonProperty = (input) => If(If(PropertyKey(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Json(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.JsonPropertyMapping(_0), input]);
export const JsonPropertyList_0 = (input, result = []) => If(If(JsonProperty(input), ([_0, input]) => If(PropertyDelimiter(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => JsonPropertyList_0(input, [...result, _0]), () => [result, input]);
export const JsonPropertyList = (input) => If(If(JsonPropertyList_0(input), ([_0, input]) => If(If(If(JsonProperty(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.JsonPropertyListMapping(_0), input]);
export const JsonObject = (input) => If(If(Token.Const('{', input), ([_0, input]) => If(JsonPropertyList(input), ([_1, input]) => If(Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.JsonObjectMapping(_0), input]);
export const JsonElementList_0 = (input, result = []) => If(If(Json(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => JsonElementList_0(input, [...result, _0]), () => [result, input]);
export const JsonElementList = (input) => If(If(JsonElementList_0(input), ([_0, input]) => If(If(If(Json(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.JsonElementListMapping(_0), input]);
export const JsonArray = (input) => If(If(Token.Const('[', input), ([_0, input]) => If(JsonElementList(input), ([_1, input]) => If(Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.JsonArrayMapping(_0), input]);
export const Json = (input) => If(If(JsonNumber(input), ([_0, input]) => [_0, input], () => If(JsonBoolean(input), ([_0, input]) => [_0, input], () => If(JsonString(input), ([_0, input]) => [_0, input], () => If(JsonNull(input), ([_0, input]) => [_0, input], () => If(JsonObject(input), ([_0, input]) => [_0, input], () => If(JsonArray(input), ([_0, input]) => [_0, input], () => [])))))), ([_0, input]) => [S.JsonMapping(_0), input]);
export const PatternBigInt = (input) => If(Token.Const('-?(?:0|[1-9][0-9]*)n', input), ([_0, input]) => [S.PatternBigIntMapping(_0), input]);
export const PatternString = (input) => If(Token.Const('.*', input), ([_0, input]) => [S.PatternStringMapping(_0), input]);
export const PatternNumber = (input) => If(Token.Const('-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', input), ([_0, input]) => [S.PatternNumberMapping(_0), input]);
export const PatternInteger = (input) => If(Token.Const('-?(?:0|[1-9][0-9]*)', input), ([_0, input]) => [S.PatternIntegerMapping(_0), input]);
export const PatternNever = (input) => If(Token.Const('(?!)', input), ([_0, input]) => [S.PatternNeverMapping(_0), input]);
export const PatternText = (input) => If(Token.Until_1(['-?(?:0|[1-9][0-9]*)n', '.*', '-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', '-?(?:0|[1-9][0-9]*)', '(?!)', '(', ')', '$', '|'], input), ([_0, input]) => [S.PatternTextMapping(_0), input]);
export const PatternBase = (input) => If(If(PatternBigInt(input), ([_0, input]) => [_0, input], () => If(PatternString(input), ([_0, input]) => [_0, input], () => If(PatternNumber(input), ([_0, input]) => [_0, input], () => If(PatternInteger(input), ([_0, input]) => [_0, input], () => If(PatternNever(input), ([_0, input]) => [_0, input], () => If(PatternGroup(input), ([_0, input]) => [_0, input], () => If(PatternText(input), ([_0, input]) => [_0, input], () => []))))))), ([_0, input]) => [S.PatternBaseMapping(_0), input]);
export const PatternGroup = (input) => If(If(Token.Const('(', input), ([_0, input]) => If(PatternBody(input), ([_1, input]) => If(Token.Const(')', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.PatternGroupMapping(_0), input]);
export const PatternUnion = (input) => If(If(If(PatternTerm(input), ([_0, input]) => If(Token.Const('|', input), ([_1, input]) => If(PatternUnion(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(PatternTerm(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.PatternUnionMapping(_0), input]);
export const PatternTerm = (input) => If(If(PatternBase(input), ([_0, input]) => If(PatternBody(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.PatternTermMapping(_0), input]);
export const PatternBody = (input) => If(If(PatternUnion(input), ([_0, input]) => [_0, input], () => If(PatternTerm(input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.PatternBodyMapping(_0), input]);
export const Pattern = (input) => If(If(Token.Const('^', input), ([_0, input]) => If(PatternBody(input), ([_1, input]) => If(Token.Const('$', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.PatternMapping(_0), input]);
export const InterfaceDeclarationHeritageList_0 = (input, result = []) => If(If(Type(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => InterfaceDeclarationHeritageList_0(input, [...result, _0]), () => [result, input]);
export const InterfaceDeclarationHeritageList = (input) => If(If(InterfaceDeclarationHeritageList_0(input), ([_0, input]) => If(If(If(Type(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.InterfaceDeclarationHeritageListMapping(_0), input]);
export const InterfaceDeclarationHeritage = (input) => If(If(If(Token.Const('extends', input), ([_0, input]) => If(InterfaceDeclarationHeritageList(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.InterfaceDeclarationHeritageMapping(_0), input]);
export const InterfaceDeclarationGeneric = (input) => If(If(Token.Const('interface', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(GenericParameters(input), ([_2, input]) => If(InterfaceDeclarationHeritage(input), ([_3, input]) => If(Properties(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.InterfaceDeclarationGenericMapping(_0), input]);
export const InterfaceDeclaration = (input) => If(If(Token.Const('interface', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(InterfaceDeclarationHeritage(input), ([_2, input]) => If(Properties(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.InterfaceDeclarationMapping(_0), input]);
export const TypeAliasDeclarationGeneric = (input) => If(If(Token.Const('type', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(GenericParameters(input), ([_2, input]) => If(Token.Const('=', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.TypeAliasDeclarationGenericMapping(_0), input]);
export const TypeAliasDeclaration = (input) => If(If(Token.Const('type', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(Token.Const('=', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.TypeAliasDeclarationMapping(_0), input]);
export const ExportKeyword = (input) => If(If(If(Token.Const('export', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExportKeywordMapping(_0), input]);
export const ModuleDeclarationDelimiter = (input) => If(If(If(Token.Const(';', input), ([_0, input]) => If(Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const(';', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(Token.Const('\n', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.ModuleDeclarationDelimiterMapping(_0), input]);
export const ModuleDeclarationList_0 = (input, result = []) => If(If(ModuleDeclaration(input), ([_0, input]) => If(ModuleDeclarationDelimiter(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => ModuleDeclarationList_0(input, [...result, _0]), () => [result, input]);
export const ModuleDeclarationList = (input) => If(If(ModuleDeclarationList_0(input), ([_0, input]) => If(If(If(ModuleDeclaration(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ModuleDeclarationListMapping(_0), input]);
export const ModuleDeclaration = (input) => If(If(ExportKeyword(input), ([_0, input]) => If(If(InterfaceDeclarationGeneric(input), ([_0, input]) => [_0, input], () => If(InterfaceDeclaration(input), ([_0, input]) => [_0, input], () => If(TypeAliasDeclarationGeneric(input), ([_0, input]) => [_0, input], () => If(TypeAliasDeclaration(input), ([_0, input]) => [_0, input], () => [])))), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ModuleDeclarationMapping(_0), input]);
export const Module = (input) => If(If(ModuleDeclaration(input), ([_0, input]) => If(ModuleDeclarationList(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ModuleMapping(_0), input]);
export const Script = (input) => If(If(Module(input), ([_0, input]) => [_0, input], () => If(GenericType(input), ([_0, input]) => [_0, input], () => If(Type(input), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.ScriptMapping(_0), input]);
